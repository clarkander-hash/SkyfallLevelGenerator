<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7x22 Grid with Images</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
width: 100%;
        }
        .grid-cell {
            height: 39px;
        }
        .grid-cell img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
  @media print {
            body {
                margin: 0;
                padding: 0;
                background: white !important;
            }
            
            header {
                display: none;
            }
                #grid1 {
                height: 7.5in !important;
                width: 3.18in !important;
                max-width: none !important;
                margin: 0 !important;
                page-break-inside: avoid;
position: absolute;
bottom:2.2in;
left:0;
            }
#grid2 { 
		height: 7.5in !important;
                width: 3.18in !important;
                max-width: none !important;
                margin: 0 !important;
                page-break-inside: avoid;
position: absolute;
bottom:2.2in;
right:0;
}
            
            .grid-cell {
                break-inside: avoid;
            }
            
            main {
                height: auto !important;
                padding: 0 !important;
            }
            
            .flex-1 {
                overflow: visible !important;
            }
        }


    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100">
    <main class="h-full flex flex-col">
        <header class="mb-4">
            <h1 class="text-2xl font-bold text-gray-800 text-center">Skyfall Level Generator</h1>
            <div class="text-center mt-4 space-x-4">
                <button id="generateBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1 px-6 rounded-lg shadow-md transition-colors">
                    Generate 2 New Levels
                </button>
                <button id="printBtn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-1 px-6 rounded-lg shadow-md transition-colors">
                    Print Levels
                </button>
            </div>
        </header>
          <div class="flex-1 gap-4 overflow-auto">
    <div class="flex justify-center">
      <div id="grid1" class="grid" style="grid-template-columns: 2fr 3fr 3fr 3fr 3fr 3fr 3fr 3fr; height: 7.5in; width: 3.18in;"><!-- Grid cells will be generated by JavaScript -->
     </div>
     <div id="grid2" class="grid" style="grid-template-columns: 2fr 3fr 3fr 3fr 3fr 3fr 3fr 3fr; height: 7.5in; width: 3.18in;"><!-- Grid cells will be generated by JavaScript -->
</div>
    </div>
   </div>
    </main>
     <script>
        // Grid state
        let gridData1 = [];
        let gridData2 = [];
        
        // Initialize grid
        function initializeGrid(totalRows = 22) {
            const gridData = [];
            for (let row = 1; row <= totalRows; row++) {
                // Add blank column (column 0)
                gridData.push({
                    row: row,
                    col: 0,
                    image: null,
                    id: `${row}-0`,
                    isBlankColumn: true
                });
                
                // Add regular columns (1-7)
                for (let col = 1; col <= 7; col++) {
                    gridData.push({
                        row: row,
                        col: col,
                        image: null,
                        id: `${row}-${col}`,
                        isBlankColumn: false
                    });
                }
            }
            return gridData;
        }

        // Get random cell from specific rows (excluding blank column)
        function getRandomCellFromRows(gridData, startRow, endRow, excludeOccupied = true) {
            const availableCells = gridData.filter(cell => 
                cell.row >= startRow && 
                cell.row <= endRow && 
                !cell.isBlankColumn &&
                (!excludeOccupied || cell.image === null)
            );
            if (availableCells.length === 0) return null;
            return availableCells[Math.floor(Math.random() * availableCells.length)];
        }

        // Get random cells from specific rows (excluding blank column)
        function getRandomCellsFromRows(gridData, startRow, endRow, count, excludeOccupied = true) {
            const availableCells = gridData.filter(cell => 
                cell.row >= startRow && 
                cell.row <= endRow && 
                !cell.isBlankColumn &&
                (!excludeOccupied || cell.image === null)
            );
            
            const selectedCells = [];
            const cellsCopy = [...availableCells];
            
            for (let i = 0; i < count && cellsCopy.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * cellsCopy.length);
                selectedCells.push(cellsCopy.splice(randomIndex, 1)[0]);
            }
            
            return selectedCells;
        }

        // Get cells with specific image from rows (excluding blank column)
        function getCellsWithImageFromRows(gridData, imageType, startRow, endRow) {
            return gridData.filter(cell => 
                cell.row >= startRow && 
                cell.row <= endRow && 
                !cell.isBlankColumn &&
                cell.image === imageType
            );
        }

        // Get one cell with specific image from each column in row range (excluding blank column)
        function getOneCellPerColumnWithImage(gridData, imageType, startRow, endRow) {
            const selectedCells = [];
            for (let col = 1; col <= 7; col++) {
                const cellsInColumn = gridData.filter(cell => 
                    cell.col === col && 
                    cell.row >= startRow && 
                    cell.row <= endRow && 
                    !cell.isBlankColumn &&
                    cell.image === imageType
                );
                if (cellsInColumn.length > 0) {
                    const randomCell = cellsInColumn[Math.floor(Math.random() * cellsInColumn.length)];
                    selectedCells.push(randomCell);
                }
            }
            return selectedCells;
        }
  // Define tetromino and triomino shapes and their rotations
        const tetrominoes = {
            I: [
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 3 }], // Horizontal
                [{ row: 0, col: 0 }, { row: 1, col: 0 }, { row: 2, col: 0 }, { row: 3, col: 0 }]  // Vertical
            ],
            O: [
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 1, col: 0 }, { row: 1, col: 1 }] // Square (no rotation needed)
            ],
            T: [
                [{ row: 0, col: 1 }, { row: 1, col: 0 }, { row: 1, col: 1 }, { row: 1, col: 2 }], // T up
                [{ row: 0, col: 0 }, { row: 1, col: 0 }, { row: 2, col: 0 }, { row: 1, col: 1 }], // T right
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 0, col: 2 }, { row: 1, col: 1 }], // T down
                [{ row: 0, col: 1 }, { row: 1, col: 0 }, { row: 1, col: 1 }, { row: 2, col: 1 }]  // T left
            ],
            L: [
                [{ row: 0, col: 0 }, { row: 1, col: 0 }, { row: 2, col: 0 }, { row: 2, col: 1 }], // L up
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 0, col: 2 }, { row: 1, col: 0 }], // L right
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 1, col: 1 }, { row: 2, col: 1 }], // L down
                [{ row: 0, col: 2 }, { row: 1, col: 0 }, { row: 1, col: 1 }, { row: 1, col: 2 }]  // L left
            ],
            J: [
                [{ row: 0, col: 1 }, { row: 1, col: 1 }, { row: 2, col: 0 }, { row: 2, col: 1 }], // J up (mirror L)
                [{ row: 0, col: 0 }, { row: 1, col: 0 }, { row: 1, col: 1 }, { row: 1, col: 2 }], // J right
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 1, col: 0 }, { row: 2, col: 0 }], // J down
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 0, col: 2 }, { row: 1, col: 2 }]  // J left
            ],
            S: [
                [{ row: 0, col: 1 }, { row: 0, col: 2 }, { row: 1, col: 0 }, { row: 1, col: 1 }], // S horizontal
                [{ row: 0, col: 0 }, { row: 1, col: 0 }, { row: 1, col: 1 }, { row: 2, col: 1 }]  // S vertical
            ],
            Z: [
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 1, col: 1 }, { row: 1, col: 2 }], // Z horizontal
                [{ row: 0, col: 1 }, { row: 1, col: 0 }, { row: 1, col: 1 }, { row: 2, col: 0 }]  // Z vertical
            ],
            // Triomino shapes (3 pieces each)
            I3: [
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 0, col: 2 }], // Horizontal line
                [{ row: 0, col: 0 }, { row: 1, col: 0 }, { row: 2, col: 0 }]  // Vertical line
            ],
            V3: [
                [{ row: 0, col: 0 }, { row: 1, col: 0 }, { row: 1, col: 1 }], // L-shape (corner)
                [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 1, col: 1 }], // Rotated 90°
                [{ row: 0, col: 1 }, { row: 1, col: 0 }, { row: 1, col: 1 }], // Rotated 180°
                [{ row: 0, col: 0 }, { row: 1, col: 0 }, { row: 0, col: 1 }]  // Rotated 270°
            ]
        };

        // Place a random tetromino shape in the grid
        function placeTetrominoShape(gridData, usedImages = new Set()) {
            // Define middle area (rows 8-15, columns 2-5 to ensure shapes fit)
            const minRow = 6;
            const maxRow = 15;
            const minCol = 1;
            const maxCol = 6;
            
            // Choose random tetromino and rotation
            const shapeNames = Object.keys(tetrominoes);
            const shapeName = shapeNames[Math.floor(Math.random() * shapeNames.length)];
            const rotations = tetrominoes[shapeName];
            const rotation = rotations[Math.floor(Math.random() * rotations.length)];
            
 // Choose a unique image for this shape (not used by other polyominoes in this grid)
            const availableImages = [];
            for (let i = 1; i <= 7; i++) {
                if (!usedImages.has(i)) {
                    availableImages.push(i);
                }
            }
            
            // If no unique images available, fall back to any image
            if (availableImages.length === 0) {
                availableImages.push(...[1, 2, 3, 4, 5, 6, 7]);
            }
            
            const randomImage = availableImages[Math.floor(Math.random() * availableImages.length)];
            

            // Try to find a valid position
            let attempts = 0;
            while (attempts < 50) {
                const baseRow = Math.floor(Math.random() * (maxRow - minRow)) + minRow;
                const baseCol = Math.floor(Math.random() * (maxCol - minCol)) + minCol;
                
                // Calculate actual positions based on base position
                const positions = rotation.map(offset => ({
                    row: baseRow + offset.row,
                    col: baseCol + offset.col
                }));
                
                // Check if all positions are valid and available
                const cells = positions.map(pos => 
                    gridData.find(cell => 
                        cell.row === pos.row && 
                        cell.col === pos.col && 
                        !cell.isBlankColumn &&
                        pos.row >= 1 && pos.row <= 18 && // Stay within valid rows
                        pos.col >= 1 && pos.col <= 7     // Stay within valid columns
                    )
                ).filter(cell => cell && cell.image === null);
                  // Check if we have the right number of cells (3 for triominoes, 4 for tetrominoes)
                const expectedCells = (shapeName === 'I3' || shapeName === 'V3') ? 3 : 4;
                
                if (cells.length === expectedCells) {
                    // Place the shape with the same image in all squares
                    cells.forEach(cell => {
                        cell.image = `tetromino_${shapeName}_${randomImage}`; // Same image for all squares in this shape
                    });
                     // Mark this image as used
                    usedImages.add(randomImage);
                    
                    return { shape: shapeName, success: true, imageUsed: randomImage };
                }
                attempts++;
            }
    return { shape: shapeName, success: false, imageUsed: null };
        }

        // Generate layout following the rules
        function generateLayout(gridData, numShapes) {
           // Clear all images first
            gridData.forEach(cell => cell.image = null);
            
           // STEP 1: Place random number of tetromino shapes (1-3)
                 const usedPolyominoImages = new Set();
            for (let i = 0; i < numShapes; i++) {
                const result = placeTetrominoShape(gridData, usedPolyominoImages);
                // usedPolyominoImages is automatically updated by the function
            }
const maxContentRow = 17+numShapes;
            // Step 1: Place Image 1
            // 1 in row 1
           let cell = getRandomCellFromRows(gridData, 1, 1);
            if (cell) cell.image = 1;
            
            // 2 more in rows 2-5
	let randomPlatformPowerup = Math.floor(Math.random() * 6)+12;
	
	let randomPlatformPowerup2 = Math.floor(Math.random() * 6)+12;
if (randomPlatformPowerup2 === randomPlatformPowerup){
randomPlatformPowerup2 = randomPlatformPowerup2 + 1;
}
if (randomPlatformPowerup2 === 18){
randomPlatformPowerup2 = 12;
}
            let cells = getRandomCellsFromRows(gridData, 2, 5, 2);
            cells.forEach(cell => cell.image = 1);
            
            // 2 more in rows 6-10
            cells = getRandomCellsFromRows(gridData, 6, 10, 2);
            cells.forEach(cell => cell.image = 1);
            
            // 1 more Powerup Platform in rows 6-9
            cells = getRandomCellsFromRows(gridData, 6, 9, 1);
            cells.forEach(cell => cell.image = randomPlatformPowerup);

            // 1 more Powerup Platform in rows 10-13
            cells = getRandomCellsFromRows(gridData, 10, 13, 1);
            cells.forEach(cell => cell.image = randomPlatformPowerup2);

            // 2 more in rows 11-15
            cells = getRandomCellsFromRows(gridData, 11, 15, 2);
            cells.forEach(cell => cell.image = 1);
         
            // 2 more in rows 16-18
            cells = getRandomCellsFromRows(gridData, 16, maxContentRow, 2);
             cells.forEach(cell => cell.image = 1);

            
            // STEP 3: Place Image 2 with specific counts per row range (counting polyomino shapes)
            for (let row = 1; row <= maxContentRow; row++) {
                // Count existing polyomino shapes in this row (they count as Image 2)
                const existingPolyominoCount = gridData.filter(cell => 
                    cell.row === row && 
                    !cell.isBlankColumn && 
                    cell.image && 
                    cell.image.toString().startsWith('tetromino_')
                ).length;
                
                // Determine target Image 2 count based on row
                let targetImage2Count;
                if (row === 1) {
                    targetImage2Count = 1;
                } else if (row >= 2 && row <= 5) {
                    targetImage2Count = 2;
                } else if (row >= 6 && row <= 10) {
                    targetImage2Count = 3;
                } else if (row >= 11 && row <= 15) {
                    targetImage2Count = 4;
                } else if (row >= 16 && row <= maxContentRow) {
                    targetImage2Count = 5;
                }
                
                // Only place additional Image 2s if we have fewer polyomino shapes than the target
                const remainingImage2Slots = Math.max(0, targetImage2Count - existingPolyominoCount);
                
                const availableCells = gridData.filter(cell => 
                    cell.row === row && 
                    !cell.isBlankColumn && 
                    cell.image === null
                );
                
                for (let i = 0; i < remainingImage2Slots; i++) {
                    const randomIndex = Math.floor(Math.random() * availableCells.length);
                    const selectedCell = availableCells.splice(randomIndex, 1)[0];
                    selectedCell.image = 2;
                }
            }

       

 	// Step 4: Replace Image 2 with Image 4
            // 1 random from rows 1-5
            let availableCells = getCellsWithImageFromRows(gridData, 2, 1, 5);
            for (let i = availableCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availableCells[i], availableCells[j]] = [availableCells[j], availableCells[i]];
            }
            cells = availableCells.slice(0, 1);
            cells.forEach(cell => cell.image = 4);
            
            // 1 random from rows 6-10
            availableCells = getCellsWithImageFromRows(gridData, 2, 6, 10);
            for (let i = availableCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availableCells[i], availableCells[j]] = [availableCells[j], availableCells[i]];
            }
            cells = availableCells.slice(0, 1);
            cells.forEach(cell => cell.image = 4);
            
            // 1 random from rows 11-15
            availableCells = getCellsWithImageFromRows(gridData, 2, 11, 15);
            for (let i = availableCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availableCells[i], availableCells[j]] = [availableCells[j], availableCells[i]];
            }
            cells = availableCells.slice(0, 1);
            cells.forEach(cell => cell.image = 4);
            
            // 1 random from rows 16-18
            availableCells = getCellsWithImageFromRows(gridData, 2, 16, 18);
            for (let i = availableCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availableCells[i], availableCells[j]] = [availableCells[j], availableCells[i]];
            }
            cells = availableCells.slice(0, 1);
            cells.forEach(cell => cell.image = 4);

            // Step 5: Place Image 5 (one per every 5 rows from 1-15)
            for (let startRow = 1; startRow <= 16; startRow += 5) {
                const endRow = Math.min(startRow + 4, 15);
                cell = getRandomCellFromRows(gridData, startRow, endRow);
                if (cell) cell.image = 5;
            }

            // Step 6: Place Image 6 (one per every 3 rows from 2-16)
            for (let startRow = 2; startRow <= 15; startRow += 3) {
                const endRow = Math.min(startRow + 2, 16);
                cell = getRandomCellFromRows(gridData, startRow, endRow);
                if (cell) cell.image = 6;
            }

            // Step 7: Place Image 7 (one per every 4 rows from 2-16)
            for (let startRow = 2; startRow <= 16; startRow += 4) {
                const endRow = Math.min(startRow + 3, 16);
                cell = getRandomCellFromRows(gridData, startRow, endRow);
                if (cell) cell.image = 7;
            }

            // Step 8: Place Images 8, 9, 10 (2 copies each in rows 5-15)
            [8, 9].forEach(imageNum => {
                cells = getRandomCellsFromRows(gridData, 5, 15, 2);
                cells.forEach(cell => cell.image = imageNum);
            });

            // Step 9: Place Image 11 (one per every 6 rows from 4-16)
            for (let startRow = 4; startRow <= 15; startRow += 6) {
                const endRow = Math.min(startRow + 5, 16);
                cell = getRandomCellFromRows(gridData, startRow, endRow);
                if (cell) cell.image = 11;
            }

            // Step 10: Place Images 12, 13, 14 in blank column (even rows 8-18)
            const evenRows = [];
            for (let row = 8; row <= 18; row += 2) {
                evenRows.push(row);
            }
            
           // Distribute images 12, 13, 14 ensuring at least 2 of each but max 3 of each
            const imageTypes = [12, 13, 14];
            const imageAssignments = [];
            const imageCounts = { 12: 0, 13: 0, 14: 0 };
            
            // First, assign 2 of each image type (minimum requirement)
            imageTypes.forEach(imageType => {
                imageAssignments.push(imageType, imageType);
                imageCounts[imageType] = 2;
            });
            
           
            
            // Shuffle the assignments
            for (let i = imageAssignments.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [imageAssignments[i], imageAssignments[j]] = [imageAssignments[j], imageAssignments[i]];
            }
            
            // Assign to blank column cells
            evenRows.forEach((row, index) => {
                const blankCell = gridData.find(cell => cell.row === row && cell.col === 0);
                if (blankCell && index < imageAssignments.length) {
                    blankCell.image = imageAssignments[index];
                }
            });
        }

        // Render the grid
        function renderGrid(gridData, gridElementId, headerRows) {
            const gridElement = document.getElementById(gridElementId);
            gridElement.innerHTML = '';
 // Update grid template rows dynamically
            gridElement.style.gridTemplateRows = `repeat(${22}, 1fr)`;

            // Sort grid data by row in descending order (22 to 1), then by column
            const sortedGridData = [...gridData].sort((a, b) => {
                if (a.row !== b.row) {
                    return b.row - a.row; // Descending order for rows
                }
                return a.col - b.col; // Ascending order for columns
            });

          sortedGridData.forEach(cellData => {
                const cellDiv = document.createElement('div');
                
                // Handle header rows (last 2 rows) as special sections
                const headerStartRow = 22 - headerRows; // Last 2 rows become headers
                if (cellData.row >= headerStartRow && cellData.row <= 22) {
                    if (cellData.col === 0) {
                        // Create spanning header for this row
                        cellDiv.className = 'bg-gray-200 border-2 border-gray-400 rounded-lg grid-cell flex items-center justify-center text-sm font-bold text-gray-700';
                        cellDiv.style.gridColumn = 'span 8';
                       
		

                        const rowTexts = {
			[23-headerRows]: 'Zap! The city is destroyed, you lose!',
                            [22-headerRows]: 'Omega Laser Firing in 3...2...1...'
                        };
                        cellDiv.textContent = rowTexts[cellData.row];
                        gridElement.appendChild(cellDiv);
                    }
                    // Skip other cells in header rows since we're spanning
                    return;
                }
                
                if (cellData.isBlankColumn) {
                    // Blank column styling
                    cellDiv.className = 'bg-gray-200 border-2 border-gray-200 rounded-0.5g grid-cell flex items-center justify-center';
                    
                    if (cellData.image) {
                        const imageUrls = {
                            12: 'loseheart.png',
                            13: 'losedice.png',
                            14: 'advance.png'
                        };
                        
                        const img = document.createElement('img');
                        img.src = imageUrls[cellData.image];
                        img.alt = `Image ${cellData.image}`;
                        img.onerror = function() {
                            this.src = '';
                            this.alt = 'Image failed to load';
                            this.style.display = 'none';
                        };
                        cellDiv.appendChild(img);
                    }
                } else {
                    cellDiv.className = 'bg-white border-2 border-gray-400 flex items-center justify-center text-sm font-medium text-gray-600 hover:bg-blue-50 transition-colors grid-cell';
                    
                        if (cellData.image) {
                        if (cellData.image.toString().startsWith('tetromino_')) {
                      // Special styling for tetromino shapes with images
                            const imageParts = cellData.image.split('_');
                            const shapeName = imageParts[1];
                            const imageNumber = imageParts[2];
                           
                                     cellDiv.className = `flex items-center justify-center text-sm relative overflow-hidden`;
                         // Add the image
                            const imageUrls = {
                             	 1: 'redship.png',
                       		 2: 'blueship.png',
                       		 3: 'orangeship.png',
                       		 4: 'greyship.png',
                       		 5: 'cyanship.png',
                       		 6: 'purpleship.png',
                      		 7: 'yellowship.png',
                            };
                            
                            const img = document.createElement('img');
                            img.src = imageUrls[imageNumber];
                            img.alt = `Tetromino ${shapeName} - Image ${imageNumber}`;
                            img.className = 'w-full h-full object-cover rounded opacity-80';
                            img.onerror = function() {
                                this.src = '';
                                this.alt = 'Image failed to load';
                                this.style.display = 'none';
                            };
                            cellDiv.appendChild(img);
                        } else {
                          const imageUrls = {
                        1: 'platform.png',
                        2: 'alien.png',
                        3: 'alienred.png',
                        4: 'alienshield.png',
                        5: 'shield.png',
                        6: 'katana.png',
                        7: 'gun.png',
                        8: 'reroll.png',
                        9: 'plusminus.png',
                        10: 'mastery.png',
                        11: 'bomb.png',
                        12: 'platformboots.png',
                        13: 'platformgun.png',
                        14: 'platformshot.png',
                        15: 'platformbomb.png',
                        16: 'platformblade.png',
                        17: 'platformtele.png'
                    };
                            
                            const img = document.createElement('img');
                            img.src = imageUrls[cellData.image];
                            img.alt = `Image ${cellData.image}`;
                            img.className = 'w-full h-full object-cover rounded';
                            img.onerror = function() {
                                this.src = '';
                                this.alt = 'Image failed to load';
                                this.style.display = 'none';
                            };
                            cellDiv.appendChild(img);
                        }
                    }                 
}
           
                gridElement.appendChild(cellDiv);
            });
        }

        // Initialize and render first layout
        	const numShapes1 = Math.floor(Math.random() * 3) + 1; // 1-3 shapes
                const numShapes2 = Math.floor(Math.random() * 3) + 1; // 1-3 shapes
                
                // Calculate total rows based on number of shapes
                const headerRows1 = 4-numShapes1
                const headerRows2 = 4-numShapes2
                
                // Reinitialize grids with new row counts
                gridData1 = initializeGrid(22);
                gridData2 = initializeGrid(22);
                generateLayout(gridData1, numShapes1);
                generateLayout(gridData2, numShapes2);
                renderGrid(gridData1, 'grid1', headerRows1);
                renderGrid(gridData2, 'grid2', headerRows2);

        // Add event listener to generate button
          document.getElementById('generateBtn').addEventListener('click', function() {
                // Generate new random number of shapes for each grid
                const numShapes1 = Math.floor(Math.random() * 3) + 1; // 1-3 shapes
                const numShapes2 = Math.floor(Math.random() * 3) + 1; // 1-3 shapes
                
                // Calculate total rows based on number of shapes
                const headerRows1 = 4-numShapes1
                const headerRows2 = 4-numShapes2
                
                // Reinitialize grids with new row counts
                gridData1 = initializeGrid(22);
                gridData2 = initializeGrid(22);
                generateLayout(gridData1, numShapes1);
                generateLayout(gridData2, numShapes2);
                renderGrid(gridData1, 'grid1', headerRows1);
                renderGrid(gridData2, 'grid2', headerRows2);
 });
        // Add event listener to print button
        document.getElementById('printBtn').addEventListener('click', function() {
            window.print();
        });
    </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'99533e1ae1e6d96e',t:'MTc2MTU3OTEwOS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
